<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Race League Manager ‚Äî v13.7</title>
<style>
  :root {
    --bg: #f7f7fb;
    --panel: #ffffff;
    --text: #111827;
    --subtext: #374151;
    --muted: #6b7280;
    --border: #e5e7eb;
    --accent: #2563eb;
    --accent-weak: #bfdbfe;
    --good: #16a34a;
    --bad: #dc2626;
    --chip: #eef2ff;
    --chip-text: #1f2937;
    --input-bg: #ffffff;
    --shadow: 0 6px 18px rgba(0,0,0,.06);
  }
  [data-theme="dark"] {
    --bg: #0b1220;
    --panel: #0f172a;
    --text: #f3f4f6;
    --subtext: #c7d2fe;
    --muted: #94a3b8;
    --border: #1f2a44;
    --accent: #60a5fa;
    --accent-weak: #1e3a8a;
    --good: #22c55e;
    --bad: #f87171;
    --chip: #172554;
    --chip-text: #e5e7eb;
    --input-bg: #0b1220;
    --shadow: 0 6px 18px rgba(0,0,0,.25);
  }
  * { box-sizing: border-box; }

<script>
/* ===== Force-load JSON into the editor's localStorage, then reload once ===== */
(function () {
  const MARKER = 'RLM_JSON_LOADED_ONCE';
  const DATA_URL = './data/race-league-manager.json';

  // If we've already injected once, don't loop reloads
  if (sessionStorage.getItem(MARKER)) return;

  // Helper: set JSON to any likely storage keys used by the app
  function writeToLikelyKeys(jsonStr) {
    const likelyKeys = new Set([
      'race-league-manager-state',
      'raceLeagueManagerState',
      'RLM_STATE',
      'RaceLeagueManager',
      'appState'
    ]);
    // also include any existing keys that look related
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      if (/(race|league|manager|rlm).*state/i.test(k)) likelyKeys.add(k);
    }
    likelyKeys.forEach(k => localStorage.setItem(k, jsonStr));
  }

  // Fetch your repo JSON and store it so the editor build will use it
  fetch(DATA_URL, { cache: 'no-store' })
    .then(r => r.json())
    .then(obj => {
      const jsonStr = JSON.stringify(obj);
      writeToLikelyKeys(jsonStr);
      // Mark so we only reload once
      sessionStorage.setItem(MARKER, '1');
      // Reload so the original appboots from localStorage with your data
      location.reload();
    })
    .catch(err => console.error('Failed to fetch JSON:', err));
})();
</script>

  
  body { margin:0; padding:0; background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial;
  }
  header { position: sticky; top:0; z-index: 10; background: var(--panel); border-bottom:1px solid var(--border); }
  .container { max-width: 1200px; margin: 0 auto; padding: 16px; }
  .row { display:flex; align-items:center; gap:12px; flex-wrap: wrap; }
  h1 { margin:0; font-size: 20px; }
  .spacer { flex:1; }
  .btn { background: var(--accent); color:#fff; border:0; border-radius:10px; padding:10px 14px; cursor:pointer; box-shadow: var(--shadow); font-weight:600; }
  .btn.small { padding:6px 10px; font-size:12px; }
  .btn.secondary { background: transparent; color: var(--text); border: 1px solid var(--border); }
  .btn.ghost { background: transparent; color: var(--accent); border: 1px solid var(--accent-weak); }
  .select, .input, .textarea { background: var(--input-bg); color: var(--text); border:1px solid var(--border); border-radius:10px; padding: 10px; }
  .textarea { width:100%; min-height:140px; resize: vertical; }
  .tabs { display:flex; gap:8px; padding: 10px 16px; border-bottom:1px solid var(--border); overflow-x:auto; }
  .tab { padding:8px 12px; border-radius:999px; border:1px solid var(--border); background: var(--chip); color: var(--chip-text); cursor:pointer; white-space:nowrap; }
  .tab.active { background: var(--accent); color:#fff; border-color: var(--accent); }
  .grid { display:grid; gap:16px; }
  .panel { background: var(--panel); border:1px solid var(--border); border-radius:16px; padding:16px; box-shadow: var(--shadow); }
  .panel h2 { margin:0 0 8px 0; font-size:18px; }
  .muted { color: var(--muted); font-size: 12px; }
  table { width:100%; border-collapse: collapse; }
  th, td { border-bottom:1px solid var(--border); padding:10px; text-align:left; }
  th { font-size:12px; letter-spacing:.04em; text-transform:uppercase; color: var(--subtext); cursor:pointer; }
  tr:hover td { background: rgba(99,102,241,.04); }
  .pill { padding:6px 10px; border:1px dashed var(--border); border-radius:999px; }
  .number-chip { display:inline-flex; align-items:center; gap:6px; padding: 2px 8px; border-radius:999px; border:1px solid var(--border); background: var(--chip); color: var(--chip-text); font-size:12px; }
  .color-dot { width:12px; height:12px; border-radius:50%; border:1px solid var(--border); display:inline-block; }
  .legend { display:flex; gap:10px; flex-wrap:wrap; }
  .legend-item { display:flex; align-items:center; gap:6px; font-size:12px; padding:4px 8px; border:1px solid var(--border); border-radius:999px; }
  .hidden { display:none !important; }
  .hr { height:1px; background: var(--border); margin: 12px 0; }
  .two-col { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  @media (max-width:860px){ .two-col { grid-template-columns: 1fr; } }
  /* DnD */
  .dnd-wrap { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
  .dnd-col { border:1px solid var(--border); border-radius:12px; padding:8px; min-height: 280px; background: var(--panel); }
  .dnd-col h4 { margin: 6px 6px 8px; }
  .sortable { list-style:none; margin:0; padding:0; }
  .sortable li { display:flex; align-items:center; gap:10px; border:1px solid var(--border); border-radius:10px; padding:8px 10px; margin:6px; background: var(--chip); cursor: grab; }
  .sortable li.dragging { opacity: .6; }
  .ghost { border:2px dashed var(--accent); background: transparent; height: 40px; margin: 6px; border-radius:10px; }

  /* Modal */
  dialog { border:0; background: transparent; }
  dialog::backdrop { background: rgba(0,0,0,.5); }
  .modal { width:min(900px,95vw); margin:auto; background: var(--panel); color: var(--text); border:1px solid var(--border); border-radius:16px; padding:16px; box-shadow: var(--shadow); }
  .modal h3 { margin:0 0 8px 0; }
  .scroll { max-height:60vh; overflow:auto; border:1px solid var(--border); border-radius:12px; padding:8px; }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background: var(--chip); border:1px solid var(--border); padding: 2px 6px; border-radius: 6px; }
</style>
</head>
<body>
<header>
  <div class="container">
    <div class="row">
      <h1>üèÅ Race League Manager</h1>
      <div class="pill">
        <label for="seasonSelect" class="muted">Season</label>
        <select id="seasonSelect" class="select"></select>
      </div>
      <button id="newSeasonBtn" class="btn small">‚ûï New Season</button>
      <button id="cloneSeasonBtn" class="btn small">üß¨ Clone Season</button>
      <button id="renameSeasonBtn" class="btn small">‚úèÔ∏è Rename Season</button>
      <button id="reorderSeasonsBtn" class="btn small">‚ÜïÔ∏è Reorder Seasons</button>
      <button id="deleteSeasonBtn" class="btn small secondary">üóëÔ∏è Delete Season</button>
      <div class="spacer"></div>
      <button id="themeToggle" class="btn small secondary">üåì Theme</button>
      <button id="exportBtn" class="btn small ghost">‚¨áÔ∏è Export</button>
      <label class="btn small ghost" style="cursor:pointer;">‚¨ÜÔ∏è Import
        <input id="importInput" type="file" accept="application/json" style="display:none;">
      </label>
    </div>
  </div>
  <div class="tabs container" id="tabs">
    <div class="tab active" data-tab="dashboard">Dashboard</div>
    <div class="tab" data-tab="drivers">Drivers</div>
    <div class="tab" data-tab="schedule">Schedule</div>
    <div class="tab" data-tab="results">Results</div>
    <div class="tab" data-tab="points_rules">Points & Rules</div>
    <div class="tab" data-tab="lifetime">Lifetime Stats</div>
  </div>
</header>

<main class="container" style="padding-top:12px;">
  <!-- DASHBOARD -->
  <section id="dashboard" class="grid" style="grid-template-columns: 1.2fr .8fr;">
    <div class="panel">
      <h2>Leaderboard</h2>
      <div class="muted">Click column headers to sort. Points = Qualifying + Race + Adjustments.</div>
      <div class="hr"></div>
      <table id="leaderboardTable">
        <thead>
          <tr>
            <th data-sort="name">Driver</th>
            <th>Number</th>
            <th>Color</th>
            <th data-sort="total">Total Points</th>
            <th>Quali Pts</th>
            <th>Race Pts</th>
            <th>Adj.</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="panel">
      <h2>Positions Over Time</h2>
      <div class="muted">Lower is better (P1 on top).</div>
      <div class="legend" id="posLegend"></div>
      <div class="hr"></div>
      <canvas id="posChart" width="800" height="420" style="max-width:100%;"></canvas>
    </div>
    <div class="panel">
      <h2>Season Summary</h2>
      <div id="seasonSummary" class="row" style="gap:8px;"></div>
    </div>
    <div class="panel">
      <h2>Upcoming</h2>
      <div id="upcoming" class="row" style="gap:8px;"></div>
    </div>
  </section>

  <!-- DRIVERS -->
  <section id="drivers" class="grid hidden">
    <div class="panel">
      <div class="row">
        <h2>Drivers</h2>
        <div class="spacer"></div>
        <button id="addDriverBtn" class="btn small">Add Driver</button>
      </div>
      <div class="hr"></div>
      <div class="muted">Unique car numbers enforced. Use the color picker or hex/code. Toggle Active to hide a driver.</div>
      <table id="driversTable">
        <thead><tr><th>#</th><th>Name</th><th>Number</th><th>Color</th><th>Active</th><th></th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- SCHEDULE -->
  <section id="schedule" class="grid hidden">
    <div class="panel">
      <div class="row">
        <h2>Schedule</h2>
        <div class="spacer"></div>
        <button id="addRaceBtn" class="btn small">Add Race</button>
      </div>
      <div class="hr"></div>
      <div class="muted">Practice auto-sets to one week before race. Dates shown as <span class="kbd">MM-DD-YYYY</span>.</div>
      <table id="scheduleTable">
        <thead><tr><th>Round</th><th>Track (Name / Layout)</th><th>Practice</th><th>Race</th><th>Include</th><th></th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- RESULTS -->
  <section id="results" class="grid hidden">
    <div class="panel">
      <h2>Enter Results</h2>
      <div class="muted">Drag to rank drivers for Qualifying and Race. Leave a driver out if DNP. Use Adjustments for bonuses/penalties.</div>
      <div class="hr"></div>
      <div id="resultsList"></div>
    </div>
  </section>

  <!-- POINTS & RULES -->
  <section id="points_rules" class="grid hidden">
    <div class="two-col">
      <div class="panel">
        <div class="row">
          <h2>Points</h2>
          <div class="spacer"></div>
          <button id="resetPointsBtn" class="btn small secondary">Reset Defaults</button>
        </div>
        <div class="hr"></div>
        <div class="two-col">
          <div>
            <h3 style="margin-top:0;">Qualifying</h3>
            <table id="qualiPointsTable">
              <thead><tr><th>Pos</th><th>Points</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
          <div>
            <h3 style="margin-top:0;">Race</h3>
            <table id="racePointsTable">
              <thead><tr><th>Pos</th><th>Points</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div class="hr"></div>
        <button id="extendPointsBtn" class="btn small">+ Add Position Row</button>
      </div>

      <div class="panel">
        <h2>Rules</h2>
        <textarea id="rulesText" class="textarea" placeholder="Example:
- Clean racing only; no intentional contact
- Car: GT3 class
- Tire: Softs only
- Race length: 30 laps / 45 min
- 1x mandatory pit stop"></textarea>
        <div class="hr"></div>
        <button id="saveRulesBtn" class="btn small">Save Rules</button>
      </div>
    </div>
  </section>
  <!-- LIFETIME STATS -->
  <section id="lifetime" class="grid hidden">
    <div class="panel">
      <h2>Lifetime Stats</h2>
      <div class="muted">Final season positions across all seasons.</div>
      <div class="hr"></div>
      <table id="lifetimeTable">
        <thead><tr><th>Driver</th><th>Seasons</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  
    <div class="panel">
      <h2>Progress Across Seasons</h2>
      <div class="muted">Final season finishing position by season (lower is better).</div>
      <div class="legend" id="lifetimeLegend"></div>
      <div class="hr"></div>
      <canvas id="lifetimeChart" width="1100" height="420" style="max-width:100%;"></canvas>
    </div>

  </section>
</main>

<!-- Driver Dialog -->
<dialog id="driverDialog">
  <form method="dialog" class="modal">
    <h3 id="driverDialogTitle">Add Driver</h3>
    <div class="row" style="gap:8px; margin:8px 0;">
      <input class="input" id="driverNameInput" placeholder="Driver name" required>
      <input class="input" id="driverNumberInput" placeholder="Car number (e.g., 22)" inputmode="numeric">
      <input type="color" class="input" id="driverColorPicker" value="#3b82f6" style="width:46px;height:38px;padding:0;">
      <input class="input" id="driverColorInput" placeholder="#ff0000 or css color" value="#3b82f6">
    </div>
    <div class="row" style="gap:8px;">
      <button class="btn small" value="save">Save</button>
      <button class="btn small secondary" value="cancel">Cancel</button>
    </div>
  </form>
</dialog>

<!-- Race Dialog -->
<dialog id="raceDialog">
  <form method="dialog" class="modal">
    <h3 id="raceDialogTitle">Add Race</h3>
    <div class="row" style="gap:8px; margin:8px 0;">
      <input class="input" id="raceTrackInput" placeholder="Track name / layout" style="flex:2;">
      <input class="input" id="raceDateInput" placeholder="Race date (MM-DD-YYYY)" style="flex:1;">
    </div>
    <div class="muted">Accepted formats: <span class="kbd">MM-DD-YYYY</span>, <span class="kbd">MM/DD/YYYY</span>, <span class="kbd">YYYY-MM-DD</span>.</div>
    <div class="row" style="gap:8px; margin-top:10px;">
      <button class="btn small" value="save">Save</button>
      <button class="btn small secondary" value="cancel">Cancel</button>
    </div>
  </form>
</dialog>

<!-- Reorder Seasons Dialog -->
<dialog id="reorderDialog">
  <form method="dialog" class="modal">
    <h3>Reorder Seasons</h3>
    <div class="scroll">
      <ul id="reorderList" class="sortable"></ul>
    </div>
    <div class="row" style="gap:8px; margin-top:10px;">
      <div class="spacer"></div>
      <button class="btn small" value="save">Save</button>
      <button class="btn small secondary" value="cancel">Cancel</button>
    </div>
  </form>
</dialog>

<!-- Adjustments Dialog -->
<dialog id="adjustDialog">
  <form method="dialog" class="modal">
    <h3>Adjustments ‚Äî <span id="adjustRaceTitle"></span></h3>
    <div class="muted" style="margin-bottom:8px;">Positive = bonus; Negative = penalty. Values are added to that race‚Äôs points for the selected driver.</div>
    <div id="adjustContent" class="scroll"></div>
    <div class="row" style="gap:8px; margin-top:10px;">
      <div class="spacer"></div>
      <button class="btn small" value="save">Save</button>
      <button class="btn small secondary" value="cancel">Cancel</button>
    </div>
  </form>
</dialog>

<script>
// ===== Utilities =====
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const $  = (sel, root=document) => root.querySelector(sel);

function toMMDDYYYY(d) {
  if (!(d instanceof Date)) d = new Date(d);
  if (Number.isNaN(d.getTime())) return "";
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  const yyyy = d.getFullYear();
  return `${mm}-${dd}-${yyyy}`;
}
function parseAnyDate(s) {
  if (!s) return null;
  s = String(s).trim();
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [y,m,d]=s.split("-").map(Number); return new Date(y, m-1, d); }
  if (/^\d{1,2}[\/-]\d{1,2}[\/-]\d{4}$/.test(s)) { const p=s.split(/[\/-]/).map(Number); return new Date(p[2], p[0]-1, p[1]); }
  const d = new Date(s); return Number.isNaN(d.getTime()) ? null : d;
}
function sanitizeNumberInput(v) {
  if (v == null) return 0;
  v = String(v).replace(/,/g,"").trim();
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}
function uid() { return Math.random().toString(36).slice(2,9); }

// ===== Storage structure =====
const STORAGE_KEY = "race-league-manager.v7";
function loadState() { try { const raw = localStorage.getItem(STORAGE_KEY); return raw? JSON.parse(raw): null; } catch { return null; } }
function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(app)); }
function initialSeason(name="Season 1") {
  const colors = ["#ef4444","#f97316","#eab308","#22c55e","#06b6d4","#3b82f6","#8b5cf6","#ec4899","#14b8a6","#94a3b8"];
  const drivers = Array.from({length:10}, (_,i)=>({ id:uid(), name:`Driver ${i+1}`, number:String(10+i), color: colors[i%colors.length], active:true }));
  return { name, createdAt: Date.now(), drivers, schedule: [], results: [], points:{quali:[10,9,8,7,6,5,4,3,2,1], race:[25,20,18,16,14,12,10,8,6,4,2,1]}, rules:"" };
}
let app = loadState() || { theme:"light", seasons:[initialSeason()], activeSeasonIndex:0 };

// ===== Theme =====
function applyTheme(){ document.body.setAttribute("data-theme", app.theme==="dark"?"dark":"light"); }
applyTheme();
$("#themeToggle").addEventListener("click", ()=>{ app.theme = app.theme==="dark"?"light":"dark"; applyTheme(); saveState(); });

// ===== Season Switcher =====
const seasonSelect = $("#seasonSelect");
function currentSeason(){ return app.seasons[app.activeSeasonIndex]; }
function refreshSeasonSelect(){
  seasonSelect.innerHTML = "";
  app.seasons.forEach((s,i)=>{ const opt=document.createElement("option"); opt.value=String(i); opt.textContent=s.name; seasonSelect.appendChild(opt); });
  seasonSelect.value = String(app.activeSeasonIndex);
}
refreshSeasonSelect();
seasonSelect.addEventListener("change", ()=>{ app.activeSeasonIndex = Number(seasonSelect.value); saveState(); renderAll(); });
$("#newSeasonBtn").addEventListener("click", ()=>{
  const name = prompt("New season name?", "Season " + (app.seasons.length+1)); if(!name) return;
  app.seasons.push(initialSeason(name)); app.activeSeasonIndex = app.seasons.length-1; saveState(); refreshSeasonSelect(); renderAll();
});
$("#cloneSeasonBtn").addEventListener("click", ()=>{
  const src = currentSeason(); const name = prompt("Clone into new season name?", src.name+" (Copy)"); if(!name) return;
  const cloned = JSON.parse(JSON.stringify(src)); cloned.name = name; cloned.createdAt = Date.now(); app.seasons.push(cloned); app.activeSeasonIndex = app.seasons.length-1; saveState(); refreshSeasonSelect(); renderAll();
});

// ===== Tabs =====
$("#tabs").addEventListener("click", (e)=>{
  const t = e.target.closest(".tab"); if(!t) return;
  $$(".tab").forEach(x=>x.classList.toggle("active", x===t));
  ["dashboard","drivers","schedule","results","points_rules","lifetime"].forEach(id => $("#"+id).classList.toggle("hidden", id!==t.dataset.tab));
});

// ===== Export / Import =====
$("#exportBtn").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(app,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob); const a = document.createElement("a");
  a.href = url; a.download = "race-league-manager-backup.json"; document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
});
$("#importInput").addEventListener("change", (ev)=>{
  const file = ev.target.files[0]; if(!file) return; const reader = new FileReader();
  reader.onload = () => { try { app = JSON.parse(reader.result); saveState(); refreshSeasonSelect(); renderAll(); alert("Import complete."); } catch(e){ alert("Import failed: "+e.message); } };
  reader.readAsText(file);
});

// ===== Helpers: unique car numbers =====
function isNumberTaken(number, exceptId=null){
  const season = currentSeason(); const num = String(number||"").trim(); if(!num) return false;
  return season.drivers.some(d => d.id !== exceptId && String(d.number||"").trim() === num);
}

// ===== Drivers =====
const driversTableBody = $("#driversTable tbody");
function renderDrivers(){
  const season = currentSeason(); driversTableBody.innerHTML = "";
  season.drivers.forEach((d, idx)=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="muted">${idx+1}</td>
      <td><input class="input" data-field="name" value="${d.name}"></td>
      <td style="max-width:120px;"><input class="input" data-field="number" value="${d.number}" style="width:100px;"></td>
      <td style="max-width:220px;">
        <div class="row" style="gap:8px;">
          <span class="color-dot" style="background:${d.color}"></span>
          <input type="color" class="input" data-field="colorPicker" value="${d.color}" style="width:46px;height:38px;padding:0;">
          <input class="input" data-field="color" value="${d.color}" style="width:120px;">
        </div>
      </td>
      <td><input type="checkbox" data-field="active" ${d.active? "checked":""}></td>
      <td class="nowrap">
        <button class="btn small secondary" data-action="edit">Edit</button>
        <button class="btn small secondary" data-action="delete">Delete</button>
      </td>
    `;
    driversTableBody.appendChild(tr);
    const syncColor = (v)=>{
      d.color = v;
      tr.querySelector('.color-dot').style.background = v;
      const text = tr.querySelector('input[data-field="color"]');
      const pick = tr.querySelector('input[data-field="colorPicker"]');
      if (text && text.value !== v) text.value = v;
      if (pick && pick.value !== v) pick.value = v;
    };
    tr.querySelectorAll("input").forEach(inp=>{
      inp.addEventListener("input", ()=>{
        const f = inp.dataset.field;
        if (f === "active") { d.active = inp.checked; }
        else if (f === "color") { syncColor(inp.value); }
        else if (f === "colorPicker") { syncColor(inp.value); }
        else if (f === "number") {
          const proposed = String(inp.value).trim();
          if (isNumberTaken(proposed, d.id)) {
            inp.setCustomValidity("That car number is already taken."); inp.reportValidity(); inp.style.borderColor = "var(--bad)"; return;
          } else { inp.setCustomValidity(""); inp.style.borderColor = ""; d.number = proposed; }
        } else { d.name = inp.value; }
        saveState();
        // Update dependent sections only
        renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
      });
    });
    tr.querySelector('[data-action="edit"]').addEventListener("click", ()=>openDriverDialog(d));
    tr.querySelector('[data-action="delete"]').addEventListener("click", ()=>{
      if (!confirm(`Delete driver "${d.name}"?`)) return;
      season.drivers.splice(idx,1);
      season.results.forEach(r=>{ Object.keys(r.byDriver||{}).forEach(id=>{ if(id===d.id) delete r.byDriver[id]; }); if (r.adjustments) delete r.adjustments[d.id]; });
      saveState(); renderAll();
    });
  });
}
$("#addDriverBtn").addEventListener("click", ()=>openDriverDialog());

// Driver dialog
const driverDialog = $("#driverDialog");
const driverNameInput = $("#driverNameInput");
const driverNumberInput = $("#driverNumberInput");
const driverColorInput = $("#driverColorInput");
const driverColorPicker = $("#driverColorPicker");
let editDriverId = null;
function openDriverDialog(driver=null){
  editDriverId = driver? driver.id : null;
  $("#driverDialogTitle").textContent = driver? "Edit Driver" : "Add Driver";
  driverNameInput.value = driver?.name || "";
  driverNumberInput.value = driver?.number || "";
  const color = driver?.color || "#3b82f6";
  driverColorInput.value = color; driverColorPicker.value = color;
  driverColorPicker.oninput = ()=>{ driverColorInput.value = driverColorPicker.value; };
  driverColorInput.oninput = ()=>{ driverColorPicker.value = driverColorInput.value; };
  driverDialog.showModal();
}
driverDialog.addEventListener("close", ()=>{
  if (driverDialog.returnValue !== "save") return;
  const name = driverNameInput.value.trim();
  const number = (driverNumberInput.value||"").trim();
  const color = (driverColorInput.value||"").trim();
  if (!name) return;
  const season = currentSeason();
  if (number && isNumberTaken(number, editDriverId)) { alert("That car number is already taken."); return; }
  if (editDriverId){
    const d = season.drivers.find(x=>x.id===editDriverId); if (!d) return;
    d.name = name; d.number = number; d.color = color;
  } else {
    season.drivers.push({ id: uid(), name, number, color, active:true });
  }
  saveState(); renderAll();
});

// ===== Schedule =====
const scheduleTableBody = $("#scheduleTable tbody");
$("#addRaceBtn").addEventListener("click", ()=>openRaceDialog());
const raceDialog = $("#raceDialog");
const raceTrackInput = $("#raceTrackInput");
const raceDateInput = $("#raceDateInput");
let editRaceId = null;
function openRaceDialog(race=null){
  editRaceId = race?.id || null;
  $("#raceDialogTitle").textContent = race? "Edit Race" : "Add Race";
  raceTrackInput.value = race?.track || "";
  raceDateInput.value = race?.raceDate ? toMMDDYYYY(new Date(race.raceDate)) : "";
  raceDialog.showModal();
}
raceDialog.addEventListener("close", ()=>{
  if (raceDialog.returnValue !== "save") return;
  const track = (raceTrackInput.value||"").trim();
  const rd = parseAnyDate(raceDateInput.value); if (!track || !rd) { alert("Please enter Track and a valid Race Date."); return; }
  const practice = new Date(rd.getTime() - 7*24*3600*1000);
  const season = currentSeason();
  if (editRaceId){
    const r = season.schedule.find(x=>x.id===editRaceId); if(!r) return;
    r.track = track; r.raceDate = rd.toISOString(); r.practiceDate = practice.toISOString();
  } else {
    const round = (season.schedule?.length || 0) + 1;
    season.schedule.push({ id: uid(), round, track, raceDate: rd.toISOString(), practiceDate: practice.toISOString(), includeInStats: true });
  }
  season.schedule.sort((a,b)=> new Date(a.raceDate) - new Date(b.raceDate));
  season.schedule.forEach((r,i)=> r.round = i+1);
  saveState(); renderAll();
});
function renderSchedule(){
  const season = currentSeason(); scheduleTableBody.innerHTML = "";
  season.schedule.forEach(r=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.round}</td>
      <td>${r.track}</td>
      <td>${toMMDDYYYY(new Date(r.practiceDate))}</td>
      <td>${toMMDDYYYY(new Date(r.raceDate))}</td>
      <td><input type="checkbox" data-field="include" ${r.includeInStats!==false? "checked": ""}></td>
      <td class="nowrap">
        <button class="btn small secondary" data-action="edit">Edit</button>
        <button class="btn small secondary" data-action="delete">Delete</button>
      </td>`;
    scheduleTableBody.appendChild(tr);
    tr.querySelector('[data-action="edit"]').addEventListener("click", ()=>openRaceDialog(r));
    const includeBox = tr.querySelector('input[data-field="include"]');
    if (includeBox) {
      includeBox.addEventListener("change", ()=>{
        r.includeInStats = includeBox.checked;
        saveState(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
      });
    }
    tr.querySelector('[data-action="delete"]').addEventListener("click", ()=>{
      if (!confirm(`Delete Round ${r.round} ‚Äî ${r.track}?`)) return;
      const season = currentSeason();
      season.results = season.results.filter(x=>x.raceId !== r.id);
      season.schedule = season.schedule.filter(x=>x.id !== r.id);
      season.schedule.sort((a,b)=> new Date(a.raceDate) - new Date(b.raceDate));
      season.schedule.forEach((x,i)=> x.round=i+1);
      saveState(); renderAll();
    });
  });
}

// ===== Points & Rules =====
const qualiPointsTableBody = $("#qualiPointsTable tbody");
const racePointsTableBody  = $("#racePointsTable tbody");
function renderPointsTables(){
  const season = currentSeason();
  function fill(tbody, arr){
    tbody.innerHTML = "";
    arr.forEach((pts,i)=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="muted">P${i+1}</td>
        <td><input class="input points" data-index="${i}" value="${pts}" inputmode="numeric" pattern="[0-9,\\.\\s-]*"></td>`;
      tbody.appendChild(tr);
      const inp = tr.querySelector("input");
      inp.addEventListener("input", (e)=>{ arr[i] = e.target.value; saveState(); });
      const commit = ()=>{ const v = sanitizeNumberInput(inp.value); arr[i] = v; inp.value = String(v); saveState(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart(); };
      inp.addEventListener("blur", commit);
      inp.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); inp.blur(); } });
    });
  }
  fill(qualiPointsTableBody, season.points.quali);
  fill(racePointsTableBody,  season.points.race);
}
$("#extendPointsBtn").addEventListener("click", ()=>{
  const s=currentSeason(); const len = Math.max(s.points.quali.length, s.points.race.length)+1;
  s.points.quali[len-1] = s.points.quali[len-2] ?? 0; s.points.race[len-1] = s.points.race[len-2] ?? 0;
  saveState(); renderPointsTables();
});
$("#resetPointsBtn").addEventListener("click", ()=>{
  if (!confirm("Reset points to defaults?")) return;
  const s=currentSeason(); s.points.quali=[10,9,8,7,6,5,4,3,2,1]; s.points.race=[25,20,18,16,14,12,10,8,6,4,2,1];
  saveState(); renderPointsTables(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
});
const rulesText = $("#rulesText");
$("#saveRulesBtn").addEventListener("click", ()=>{ currentSeason().rules = rulesText.value; saveState(); alert("Rules saved."); });

// ===== Results: Drag & Drop ordering + Adjustments =====
const resultsList = $("#resultsList");
function ensureResultsEntries(){
  const s = currentSeason();
  s.schedule.forEach(r=>{
    if (!s.results.find(x=>x.raceId===r.id)) s.results.push({ raceId: r.id, byDriver: {}, adjustments: {} });
  });
  s.results = s.results.filter(x=> s.schedule.some(r=> r.id===x.raceId));
}
function driverItemHTML(d){
  return `<li draggable="true" data-id="${d.id}"><span class="color-dot" style="background:${d.color}"></span>${d.name}<span class="muted" style="margin-left:auto;">#${d.number||"-"}</span></li>`;
}
function makeSortable(ul, onUpdate){
  let dragEl=null, ghost=null;
  ul.addEventListener("dragstart", (e)=>{
    dragEl = e.target.closest("li"); if(!dragEl) return; dragEl.classList.add("dragging"); e.dataTransfer.effectAllowed="move";
    ghost = document.createElement("div"); ghost.className="ghost"; dragEl.parentNode.insertBefore(ghost, dragEl.nextSibling);
  });
  ul.addEventListener("dragend", ()=>{ if(dragEl){ dragEl.classList.remove("dragging"); dragEl=null; } if(ghost){ ghost.remove(); ghost=null; } onUpdate(); });
  ul.addEventListener("dragover", (e)=>{
    e.preventDefault();
    const after = Array.from(ul.querySelectorAll("li:not(.dragging)")).find(li => {
      const rect = li.getBoundingClientRect(); return e.clientY < rect.top + rect.height/2;
    });
    if (ghost){
      if (!after) ul.appendChild(ghost); else ul.insertBefore(ghost, after);
    }
  });
  ul.addEventListener("drop", (e)=>{
    e.preventDefault();
    if(ghost && dragEl){ ul.insertBefore(dragEl, ghost); }
  });
}
const adjustDialog = $("#adjustDialog");
const adjustContent = $("#adjustContent");
const adjustRaceTitle = $("#adjustRaceTitle");
let adjustingRaceId = null;
function openAdjustments(race){
  adjustingRaceId = race.id;
  adjustRaceTitle.textContent = `Round ${race.round} ‚Äî ${race.track}`;
  const s=currentSeason();
  const entry = s.results.find(x=>x.raceId===race.id);
  const drivers = s.drivers;
  // Build a table of drivers with numeric input and note
  const table = document.createElement("table");
  table.style.width="100%"; table.style.borderCollapse="collapse";
  table.innerHTML = `<thead><tr>
    <th style="text-align:left; padding:8px;">Driver</th>
    <th style="text-align:left; padding:8px;">Adj. Points (+/-)</th>
    <th style="text-align:left; padding:8px;">Reason / Note</th>
  </tr></thead><tbody></tbody>`;
  const tbody = table.querySelector("tbody");
  drivers.forEach(d=>{
    const adj = entry.adjustments?.[d.id] || {points:"", note:""};
    const tr = document.createElement("tr");
    tr.innerHTML = `<td style="padding:8px;"><span class="number-chip"><span class="color-dot" style="background:${d.color}"></span>${d.name}</span></td>
      <td style="padding:8px; max-width:140px;"><input class="input" data-driver="${d.id}" data-field="points" placeholder="e.g., 1 or -3" value="${adj.points}"></td>
      <td style="padding:8px;"><input class="input" data-driver="${d.id}" data-field="note" placeholder="Fastest Lap, Penalty, etc." value="${adj.note||""}"></td>`;
    tbody.appendChild(tr);
  });
  adjustContent.innerHTML = ""; adjustContent.appendChild(table);
  adjustDialog.showModal();
}
adjustDialog.addEventListener("close", ()=>{
  if (adjustDialog.returnValue !== "save") return;
  const s=currentSeason(); const entry = s.results.find(x=>x.raceId===adjustingRaceId); if (!entry) return;
  entry.adjustments = entry.adjustments || {};
  // Read inputs
  const pointsInputs = $$('input[data-field="points"]', adjustContent);
  const noteInputs = $$('input[data-field="note"]', adjustContent);
  const notesMap = Object.fromEntries(noteInputs.map(i=> [i.dataset.driver, i.value]));
  pointsInputs.forEach(inp=>{
    const id = inp.dataset.driver;
    const raw = inp.value.trim();
    const val = raw === "" ? "" : sanitizeNumberInput(raw);
    const note = notesMap[id] || "";
    if (raw === "" && note === "") {
      delete entry.adjustments[id];
    } else {
      entry.adjustments[id] = { points: (raw===""? "" : val), note };
    }
  });
  saveState(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
});

function renderResults(){
  const s = currentSeason(); resultsList.innerHTML = "";
  if (!s.schedule.length){ resultsList.innerHTML = `<div class="muted">No races yet. Add races in the <span class="kbd">Schedule</span> tab.</div>`; return; }
  ensureResultsEntries();
  s.schedule.forEach(r=>{
    const entry = s.results.find(x=>x.raceId===r.id);
    const panel = document.createElement("div"); panel.className="panel";
    panel.innerHTML = `
      <div class="row">
        <h3 style="margin:0;">Round ${r.round} ‚Äî ${r.track}</h3>
        <span class="muted" style="margin-left:8px;">Practice: ${toMMDDYYYY(new Date(r.practiceDate))} ¬∑ Race: ${toMMDDYYYY(new Date(r.raceDate))}</span>
        <div class="spacer"></div>
        <button class="btn small secondary" data-action="adjust">Adjustments</button>
        <button class="btn small secondary" data-action="clear">Clear</button>
      </div>
      <div class="hr"></div>
      <div class="dnd-wrap">
        <div class="dnd-col">
          <h4>Qualifying Order</h4>
          <ul class="sortable quali"></ul>
        </div>
        <div class="dnd-col">
          <h4>Race Finish Order</h4>
          <ul class="sortable race"></ul>
          
        </div>
      </div>
    `;
    resultsList.appendChild(panel);

    // Build initial lists
    const drivers = [...s.drivers];
    const idToDriver = Object.fromEntries(drivers.map(d=>[d.id,d]));
    function buildList(kind){
      const ul = panel.querySelector("ul."+kind);
      let orderIds = [];
      const allPairs = Object.entries(entry.byDriver||{}).map(([id,vals])=> ({id, pos: sanitizeNumberInput(vals[kind==="quali"?"qualiPos":"racePos"])}));
      allPairs.sort((a,b)=> a.pos - b.pos || (idToDriver[a.id]?.name||"").localeCompare(idToDriver[b.id]?.name||""));
      orderIds = allPairs.filter(p=>p.pos>0).map(p=>p.id);
      const remaining = drivers.filter(d=>d.active !== false && !orderIds.includes(d.id)).sort((a,b)=> a.name.localeCompare(b.name)).map(d=>d.id);
      orderIds = [...orderIds, ...remaining];
      ul.innerHTML = orderIds.map(id=> {
  const d = idToDriver[id];
  const by = entry.byDriver || {};
  const flags = by[id] || {};
  const numberTag = `<span class=\"muted\" style=\"margin-left:auto;\">#${d.number||"-"} </span>`;
  if (kind==="race") {
    const checked = flags.dnf ? "checked" : "";
    return `<li draggable=\"true\" data-id=\"${id}\"><span class=\"color-dot\" style=\"background:${d.color}\"></span>${d.name}${numberTag}<label class=\"muted\" style=\"display:flex; align-items:center; gap:6px; margin-left:8px;\"><input type=\"checkbox\" class=\"dnfBox\" data-id=\"${id}\" ${checked}> DNF</label></li>`;
  } else {
    const qChecked = flags.qDNP ? "checked" : "";
    return `<li draggable=\"true\" data-id=\"${id}\"><span class=\"color-dot\" style=\"background:${d.color}\"></span>${d.name}${numberTag}<label class=\"muted\" style=\"display:flex; align-items:center; gap:6px; margin-left:8px;\"><input type=\"checkbox\" class=\"dnpBox\" data-id=\"${id}\" ${qChecked}> DNP</label></li>`;
  }
}).join("");
      const onUpdate = ()=>{
        const ids = Array.from(ul.querySelectorAll("li")).map(li=> li.dataset.id);
        ids.forEach((id, i)=>{
          if (!entry.byDriver[id]) entry.byDriver[id] = { qualiPos:"", racePos:"" };
          if (kind==="quali") entry.byDriver[id].qualiPos = i+1;
          else entry.byDriver[id].racePos = i+1;
        });
        saveState(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
      };
      makeSortable(ul, onUpdate);
      if (kind==="race") {
        ul.querySelectorAll(".dnfBox").forEach(cb=>{
          cb.addEventListener("click", ev=> ev.stopPropagation());
          cb.addEventListener("change", (e)=>{
            const id = e.target.dataset.id;
            if (!entry.byDriver[id]) entry.byDriver[id] = { qualiPos:"", racePos:"" };
            entry.byDriver[id].dnf = e.target.checked;
            saveState(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
          });
        });
      } else {
        ul.querySelectorAll(".dnpBox").forEach(cb=>{
          cb.addEventListener("click", ev=> ev.stopPropagation());
          cb.addEventListener("change", (e)=>{
            const id = e.target.dataset.id;
            if (!entry.byDriver[id]) entry.byDriver[id] = { qualiPos:"", racePos:"" };
            entry.byDriver[id].qDNP = e.target.checked;
            saveState(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
          });
        });
      }
    }
    buildList("quali");
    buildList("race");

    panel.querySelector('[data-action="clear"]').addEventListener("click", ()=>{
      if (!confirm(`Clear all results for Round ${r.round}?`)) return;
      entry.byDriver = {}; entry.adjustments = {}; saveState(); renderAll();
    });
    panel.querySelector('[data-action="adjust"]').addEventListener("click", ()=> openAdjustments(r));
  });
}

// ===== Leaderboard & Summary =====
const leaderboardTBody = $("#leaderboardTable tbody");
let sortKey="total", sortAsc=false;
function computePointsByDriver(){
  const s = currentSeason(); const qp = s.points.quali, rp = s.points.race;
  const map = {}; s.drivers.forEach(d=> map[d.id] = {id:d.id, name:d.name, number:d.number, color:d.color, active:d.active!==false, qualiPts:0, racePts:0, adjPts:0, total:0});
  const isIncluded = (raceId)=>{ const r = s.schedule.find(x=>x.id===raceId); return !r || r.includeInStats !== false; };
  for (const entry of s.results){
    if (!isIncluded(entry.raceId)) continue;
    for (const [id, vals] of Object.entries(entry.byDriver||{})){
      const qpos = Number(vals.qualiPos)||0, rpos = Number(vals.racePos)||0;
      if (qpos>0 && !vals.qDNP && qp[qpos-1]!=null) map[id].qualiPts += qp[qpos-1];
      if (rpos>0 && !vals.dnf && rp[rpos-1]!=null) map[id].racePts += rp[rpos-1];
    }
    // apply adjustments
    if (entry.adjustments){
      for (const [id, adj] of Object.entries(entry.adjustments)){
        const val = (adj.points==="" || adj.points==null) ? 0 : Number(adj.points)||0;
        if (map[id]) map[id].adjPts += val;
      }
    }
  }
  Object.values(map).forEach(d=> d.total = d.qualiPts + d.racePts + d.adjPts);
  return map;
}
function renderLeaderboard(){
  const map = computePointsByDriver(); let rows = Object.values(map);
  if (sortKey==="name") rows.sort((a,b)=> a.name.localeCompare(b.name) * (sortAsc?1:-1));
  else rows.sort((a,b)=> (a.total - b.total) * (sortAsc?1:-1));
  leaderboardTBody.innerHTML = "";
  rows.forEach(d=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td><span class="number-chip"><span class="color-dot" style="background:${d.color}"></span>${d.name}</span></td>
      <td>${d.number||"-"}</td>
      <td><span class="color-dot" style="background:${d.color}"></span></td>
      <td><strong>${d.total}</strong></td>
      <td>${d.qualiPts}</td>
      <td>${d.racePts}</td>
      <td>${d.adjPts}</td>`;
    leaderboardTBody.appendChild(tr);
  });
}
$$('#leaderboardTable th[data-sort]').forEach(th=> th.addEventListener("click", ()=>{
  const key = th.dataset.sort; if (sortKey===key) sortAsc = !sortAsc; else { sortKey = key; sortAsc = key==="name"; } renderLeaderboard();
}));

// ===== Season Summary & Upcoming =====
function renderSeasonSummary(){
  const s = currentSeason(); const map = computePointsByDriver();
  const activeDrivers = s.drivers.filter(d=>d.active!==false).length;
  const races = s.schedule.length;
  const included = s.schedule.filter(r=> r.includeInStats !== false).length;
  const resultsEntered = s.results.filter(e=> Object.keys(e.byDriver||{}).length>0 && (s.schedule.find(r=>r.id===e.raceId)?.includeInStats !== false)).length;
  $("#seasonSummary").innerHTML = `
    <div class="pill">Drivers: <strong>${s.drivers.length}</strong> (<span class="muted">${activeDrivers} active</span>)</div>
    <div class="pill">Races: <strong>${races}</strong> <span class="muted">(Included: ${included})</span></div>
    <div class="pill">Events Recorded: <strong>${resultsEntered}</strong></div>
    <div class="pill">Total Pts Leader: <strong>${Object.values(map).sort((a,b)=>b.total-a.total)[0]?.name||"‚Äî"}</strong></div>`;
  const now = new Date(); const next = s.schedule.find(r=> new Date(r.raceDate) >= now);
  if (next){
    $("#upcoming").innerHTML = `
      <div class="pill">Next: <strong>Round ${next.round}</strong> ‚Äî ${next.track}</div>
      <div class="pill">Practice: <strong>${toMMDDYYYY(new Date(next.practiceDate))}</strong></div>
      <div class="pill">Race: <strong>${toMMDDYYYY(new Date(next.raceDate))}</strong></div>`;
  } else { $("#upcoming").innerHTML = `<span class="muted">No upcoming events scheduled.</span>`; }
}

// ===== Positions Over Time (Canvas) =====
const posCanvas = $("#posChart"); const ctx = posCanvas.getContext("2d"); let hiddenDrivers = new Set();
function computeStandingsAfterEachRace(){
  const s = currentSeason(); const qp = s.points.quali, rp = s.points.race;
  const racesSorted = [...s.schedule]
    .filter(r=> r.includeInStats !== false)
    .sort((a,b)=> new Date(a.raceDate) - new Date(b.raceDate));
  const ids = s.drivers.map(d=>d.id); const cum={}; ids.forEach(id=> cum[id]=0);
  const out=[];
  racesSorted.forEach(r=>{
    const entry = s.results.find(e=>e.raceId===r.id);
    if (entry){
      for (const [id,vals] of Object.entries(entry.byDriver||{})){
        const q=Number(vals.qualiPos)||0, x=Number(vals.racePos)||0;
        if(q>0 && !vals.qDNP && qp[q-1]!=null) cum[id]+=qp[q-1];
        if(x>0 && !vals.dnf && rp[x-1]!=null) cum[id]+=rp[x-1];
      }
      if (entry.adjustments){
        for (const [id,adj] of Object.entries(entry.adjustments)){
          const val = (adj.points==="" || adj.points==null) ? 0 : Number(adj.points)||0;
          cum[id] += val;
        }
      }
    }
    const ordered = ids.map(id=>({id, total:cum[id], name:s.drivers.find(d=>d.id===id)?.name||""})).sort((a,b)=> b.total-a.total || a.name.localeCompare(b.name));
    const pos={}; ordered.forEach((o,i)=> pos[o.id]=i+1);
    out.push({raceId:r.id, round:r.round, positions:pos});
  });
  return out;
}
function drawPositionsChart(){
  const s=currentSeason(); const racesSorted = [...s.schedule].sort((a,b)=> new Date(a.raceDate)-new Date(b.raceDate));
  ctx.clearRect(0,0,posCanvas.width,posCanvas.height);
  const padL=40,padR=10,padT=10,padB=30; const W=posCanvas.width-padL-padR, H=posCanvas.height-padT-padB;
  ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue("--border"); ctx.beginPath(); ctx.moveTo(padL,padT); ctx.lineTo(padL,padT+H); ctx.lineTo(padL+W,padT+H); ctx.stroke();
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue("--muted"); ctx.font="12px system-ui"; ctx.textAlign="center";
  racesSorted.forEach((r,i)=>{ const x=padL + (W * (i/Math.max(1,racesSorted.length-1))); ctx.fillText("R"+r.round, x, padT+H+18); });
  const standings = computeStandingsAfterEachRace(); if(!standings.length) return;
  const drivers = currentSeason().drivers; const maxPos = Math.max(drivers.length,1);
  const yForPos = (p)=> padT + ((p-1)/Math.max(1,maxPos-1))*H; const xFor = (i)=> padL + (W*(i/Math.max(1,standings.length-1)));
  drivers.forEach(d=>{
    if (hiddenDrivers.has(d.id)) return;
    ctx.strokeStyle = d.color||"#888"; ctx.lineWidth=2; ctx.beginPath();
    standings.forEach((s,i)=>{ const p=s.positions[d.id]||maxPos, x=xFor(i), y=yForPos(p); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
    ctx.stroke();
    standings.forEach((s,i)=>{ const p=s.positions[d.id]||maxPos, x=xFor(i), y=yForPos(p); ctx.fillStyle=d.color||"#888"; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); });
  });
  // y ticks
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue("--muted"); ctx.textAlign="right"; ctx.textBaseline="middle";
  for (let p=1;p<=Math.min(maxPos,10);p++){ const y=yForPos(p); ctx.fillText("P"+p, padL-6, y); }
  // legend
  const legend = $("#posLegend"); legend.innerHTML=""; currentSeason().drivers.forEach(d=>{
    const b=document.createElement("button"); b.className="legend-item"; b.innerHTML = `<span class="color-dot" style="background:${d.color}"></span> ${d.name}`;
    b.style.opacity = hiddenDrivers.has(d.id)? .4 : 1; b.addEventListener("click", ()=>{ if(hiddenDrivers.has(d.id)) hiddenDrivers.delete(d.id); else hiddenDrivers.add(d.id); drawPositionsChart(); b.style.opacity = hiddenDrivers.has(d.id)? .4 : 1; });
    legend.appendChild(b);
  });
}



// ===== Rename & Reorder Seasons =====
$("#renameSeasonBtn").addEventListener("click", ()=>{
  const s=currentSeason();
  const newName = prompt("Rename season:", s.name);
  if (newName && newName.trim()) { s.name = newName.trim(); saveState(); refreshSeasonSelect(); renderAll(); }
});

const reorderDialog = $("#reorderDialog");
const reorderList = $("#reorderList");
$("#reorderSeasonsBtn").addEventListener("click", ()=>{
  reorderList.innerHTML="";
  app.seasons.forEach((s,i)=>{
    const li=document.createElement("li"); li.dataset.index=i; li.innerHTML = `<span style="display:flex;align-items:center;gap:8px;"><span>${s.name}</span><span class="muted">No.</span><input class="input" style="width:72px;padding:6px 8px;" type="number" min="1" step="1" data-field="seasonNo" value="${s.seasonNo ?? (i+1)}"></span><span class="spacer"></span><button type="button" class="btn small secondary" data-dir="up">‚¨ÜÔ∏è</button><button type="button" class="btn small secondary" data-dir="down">‚¨áÔ∏è</button>`;
    reorderList.appendChild(li);
  });
  // Click-to-reorder: Up/Down arrows
  reorderList.addEventListener("click", (e)=>{
    const btn = e.target.closest('button[data-dir]');
    if(!btn) return;
    e.preventDefault(); e.stopPropagation();
    const li = btn.closest('li');
    if(btn.dataset.dir==='up' && li.previousElementSibling){
      reorderList.insertBefore(li, li.previousElementSibling);
    } else if(btn.dataset.dir==='down' && li.nextElementSibling){
      reorderList.insertBefore(li.nextElementSibling, li);
    }
  });
  reorderDialog.showModal();
});

reorderDialog.addEventListener("close", ()=>{
  if(reorderDialog.returnValue!=="save") return;
  const lis = Array.from(document.querySelectorAll("#reorderList li"));
  const newOrder = lis.map(li => {
    const original = app.seasons[Number(li.dataset.index)];
    const inp = li.querySelector('input[data-field="seasonNo"]');
    if (inp) {
      const n = parseInt(inp.value, 10);
      if (!Number.isNaN(n)) original.seasonNo = n;
    }
    return original;
  });
  const activeSeason = currentSeason();
  app.seasons = newOrder;
  app.activeSeasonIndex = app.seasons.indexOf(activeSeason);
  saveState(); refreshSeasonSelect(); renderAll();
});


// ===== Lifetime Stats =====
function computeFinalStandings(season){
  const map = {}; season.drivers.forEach(d=> map[d.id]={id:d.id,name:d.name,total:0});
  const qp=season.points.quali, rp=season.points.race;
  for(const entry of season.results){
    for(const [id,vals] of Object.entries(entry.byDriver||{})){
      const q=Number(vals.qualiPos)||0, r=Number(vals.racePos)||0;
      if(q>0 && !vals.qDNP && qp[q-1]!=null) map[id].total+=qp[q-1];
      if(r>0 && !vals.dnf && rp[r-1]!=null) map[id].total+=rp[r-1];
    }
    if(entry.adjustments){
      for(const [id,adj] of Object.entries(entry.adjustments)){
        const val=(adj.points===""||adj.points==null)?0:Number(adj.points)||0;
        map[id].total+=val;
      }
    }
  }
  return Object.values(map).sort((a,b)=>b.total-a.total||a.name.localeCompare(b.name));
}
function renderLifetime(){
  const tbody=$("#lifetimeTable tbody"); tbody.innerHTML="";
  const allDrivers={};
  const labels = app.seasons.map((s,i)=> s.seasonNo ?? (i+1));
  app.seasons.forEach((s,si)=>{
    const standings=computeFinalStandings(s);
    standings.forEach((d,idx)=>{
      if(!allDrivers[d.name]) allDrivers[d.name]=[];
      allDrivers[d.name][si]=idx+1;
    });
  });
  Object.entries(allDrivers).forEach(([name,positions])=>{
    const tdSeasons=positions.map((p,i)=>`<span class="pill">S${labels[i]}: P${p||"-"}</span>`).join(" ");
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${name}</td><td>${tdSeasons}</td>`;
    tbody.appendChild(tr);
  });
}

// ===== DNF integration =====
function applyDNF(raceEntry){
  for(const [id,vals] of Object.entries(raceEntry.byDriver||{})){
    if(vals.dnf){ vals.racePos=0; }
  }
}


// ===== Delete Season =====
if ($("#deleteSeasonBtn")) {
  $("#deleteSeasonBtn").addEventListener("click", ()=>{
    if (!confirm(`Delete "${currentSeason().name}"? This cannot be undone.`)) return;
    app.seasons.splice(app.activeSeasonIndex, 1);
    if (app.seasons.length === 0) {
      app.seasons = [initialSeason("Season 1")];
      app.activeSeasonIndex = 0;
    } else {
      app.activeSeasonIndex = Math.max(0, Math.min(app.activeSeasonIndex, app.seasons.length-1));
    }
    saveState(); refreshSeasonSelect(); renderAll();
  });
}

// ===== Render orchestration =====
function renderAll(){
  renderLifetime(); if (!document.getElementById('lifetime').classList.contains('hidden')) { drawLifetimeChart(); }
  renderDrivers(); renderSchedule(); renderPointsTables(); rulesText.value = currentSeason().rules || "";
  renderResults(); renderLeaderboard(); renderSeasonSummary(); drawPositionsChart();
}
renderAll();


// ===== Lifetime Chart (positions across seasons) =====
function _mapDriverColors(){
  const map = {};
  app.seasons.forEach(season => {
    (season.drivers||[]).forEach(d => {
      if (d && d.name) map[d.name] = d.color || map[d.name] || '#888';
    });
  });
  return map;
}
function _buildLifetimeSeries(){
  const labels = app.seasons.map((s,i)=> s.seasonNo ?? (i+1));
  const colorBy = _mapDriverColors();
  const all = {};
  app.seasons.forEach((s,si)=>{
    const standings = computeFinalStandings(s);
    standings.forEach((row,idx)=>{
      const name = row.name;
      if(!all[name]) all[name] = { color: colorBy[name] || '#888', data: Array(app.seasons.length).fill(null) };
      all[name].color = colorBy[name] || all[name].color;
      all[name].data[si] = idx+1;
    });
  });
  return { labels, series: Object.entries(all).map(([name,info])=>({name, color:info.color, data:info.data})) };
}
function drawLifetimeChart(){
  const cvs = document.getElementById("lifetimeChart");
  if (!cvs) return;
  const ctx = cvs.getContext("2d");
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const { labels, series } = _buildLifetimeSeries();
  let maxPos = 1; series.forEach(s=> s.data.forEach(v=>{ if(Number.isFinite(v)) maxPos = Math.max(maxPos, v); }));
  const padL=48, padR=20, padT=16, padB=36;
  const W=cvs.width, H=cvs.height, plotW=W-padL-padR, plotH=H-padT-padB;
  const cs = getComputedStyle(document.body);
  // grid + axes
  ctx.save();
  ctx.strokeStyle = cs.getPropertyValue('--border') || '#ddd';
  ctx.fillStyle   = cs.getPropertyValue('--muted') || '#888';
  ctx.lineWidth = 1;
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for (let p=1;p<=maxPos;p++){
    const y = padT + (p-1) * (plotH / Math.max(1,(maxPos-1||1)));
    ctx.globalAlpha=.35; ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(W-padR,y); ctx.stroke();
    ctx.globalAlpha=1; ctx.fillText("P"+p, padL-8, y);
  }
  ctx.textAlign="center"; ctx.textBaseline="top";
  labels.forEach((lab,i)=>{
    const x = padL + (labels.length<=1 ? 0 : i*(plotW/(labels.length-1)));
    ctx.fillText("S"+lab, x, H-padB+8);
  });
  ctx.restore();
  // helpers
  const xAt = i => padL + (labels.length<=1 ? 0 : i*(plotW/(labels.length-1)));
  const yAt = pos => { if(!Number.isFinite(pos)) return null; const r=(pos-1)/Math.max(1,(maxPos-1||1)); return padT + r*plotH; };
  // lines + points
  series.forEach(ser=>{
    ctx.beginPath(); let started=false;
    ser.data.forEach((v,i)=>{
      const x=xAt(i), y=yAt(v); if(y==null){ started=false; return; }
      if(!started){ ctx.moveTo(x,y); started=true; } else { ctx.lineTo(x,y); }
    });
    ctx.lineWidth=2; ctx.strokeStyle = ser.color || '#888'; ctx.stroke();
    ser.data.forEach((v,i)=>{ const y=yAt(v); if(y==null) return; const x=xAt(i); ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fillStyle=ser.color||'#888'; ctx.fill(); });
  });
  // legend
  const legend = document.getElementById("lifetimeLegend");
  if (legend){
    legend.innerHTML = "";
    series.forEach(s=>{
      const el = document.createElement("div");
      el.className="legend-item";
      el.innerHTML = `<span class="color-dot" style="background:${s.color||'#888'}"></span>${s.name}`;
      legend.appendChild(el);
    });
  }
}

// Hook: re-draw when switching to the Lifetime tab
(function(){
  const tabsEl = document.getElementById("tabs");
  if (tabsEl && !tabsEl._drawLifetimeHook){
    tabsEl._drawLifetimeHook = true;
    tabsEl.addEventListener("click", (e)=>{
      const t = e.target.closest(".tab");
      if (t && t.dataset.tab === "lifetime"){
        setTimeout(()=>{ renderLifetime(); if (!document.getElementById('lifetime').classList.contains('hidden')) { drawLifetimeChart(); } drawLifetimeChart(); }, 0);
      }
    });
  }
})();

</script>

<script>
  // === Read-Only Viewer Injection ===
  window.READ_ONLY = true;
  window.DATA_URL = './data/race-league-manager.json';

  // Make saveState a no-op so nothing gets persisted
  window.saveState = function(){};

  window.addEventListener('load', function() {
    fetch(window.DATA_URL)
      .then(r => r.json())
      .then(json => {
        window.app = json;
        try { if (typeof refreshSeasonSelect === 'function') refreshSeasonSelect(); } catch(e){}
        try { if (typeof applyTheme === 'function') applyTheme(); } catch(e){}
        try { if (typeof renderAll === 'function') renderAll(); } catch(e){}
        // Hide/disable editing controls
        const idsToHide = [
          'newSeasonBtn','cloneSeasonBtn','renameSeasonBtn','reorderSeasonsBtn','deleteSeasonBtn',
          'exportBtn','importInput','addDriverBtn','addRaceBtn','resetPointsBtn','extendPointsBtn','saveRulesBtn'
        ];
        idsToHide.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
        document.querySelectorAll('input, textarea, select, button').forEach(el => {
          const isTab = el.closest('#tabs');
          const isThemeToggle = el.id === 'themeToggle';
          if (!isTab && !isThemeToggle) {
            el.disabled = true;
            el.style.pointerEvents = 'none';
            el.style.opacity = '0.6';
          }
        });
      })
      .catch(err => console.error('Failed to load data', err));
  });
</script>

</body>
</html>
